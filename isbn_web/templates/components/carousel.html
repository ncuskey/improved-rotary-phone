<!-- Carousel partial for HTMX updates -->
<script id="carousel-books-data" type="application/json">
{{ books | tojson | safe }}
</script>
<div id="carousel-container"
     class="absolute inset-0"
     x-data="{
       currentIndex: 0,
       isHovering: false,
       books: [],
       sampledColors: {},
       bookDimensions: {},
       coverLoadErrors: {},
       rotationOffset: 0,
       targetRotation: 0,
       velocity: 0,
       lastWheelTime: 0,
       animationFrame: null,
       init() {
         // Load books from script tag
         const dataScript = document.getElementById('carousel-books-data');
         if (dataScript) {
           this.books = JSON.parse(dataScript.textContent);
         }

         // Reset state when reinitializing
         this.currentIndex = 0;
         this.rotationOffset = 0;
         this.targetRotation = 0;
         this.velocity = 0;
         this.sampledColors = {};
         this.bookDimensions = {};
         this.coverLoadErrors = {};

         // Cancel any existing animation loop
         if (this.animationFrame) {
           cancelAnimationFrame(this.animationFrame);
         }

         this.startAnimationLoop();
       },
       startAnimationLoop() {
         const animate = () => {
           // Apply velocity with easing
           if (Math.abs(this.velocity) > 0.01) {
             this.targetRotation += this.velocity;
             this.velocity *= 0.95; // Friction/decay
           } else {
             this.velocity = 0;
           }

           // Smoothly interpolate current rotation to target
           const diff = this.targetRotation - this.rotationOffset;
           if (Math.abs(diff) > 0.1) {
             this.rotationOffset += diff * 0.15; // Smooth interpolation

             // Update current index based on rotation
             const anglePerBook = 360 / this.books.length;
             const normalizedRotation = ((this.rotationOffset % 360) + 360) % 360;
             this.currentIndex = Math.round(normalizedRotation / anglePerBook) % this.books.length;
           } else {
             this.rotationOffset = this.targetRotation;
           }

           this.animationFrame = requestAnimationFrame(animate);
         };
         this.animationFrame = requestAnimationFrame(animate);
       },
       navigate(index) {
         const total = this.books.length;
         let diff = index - this.currentIndex;

         // Normalize to shortest path
         if (diff > total / 2) {
           diff -= total;
         } else if (diff < -total / 2) {
           diff += total;
         }

         this.targetRotation += diff * (360 / total);
         this.velocity = 0; // Stop momentum when clicking
         this.currentIndex = index;
       },
       nextBook() {
         this.targetRotation += (360 / this.books.length);
         this.velocity = 0;
         this.currentIndex = (this.currentIndex + 1) % this.books.length;
       },
       prevBook() {
         this.targetRotation -= (360 / this.books.length);
         this.velocity = 0;
         this.currentIndex = (this.currentIndex - 1 + this.books.length) % this.books.length;
       },
       handleWheel(event) {
         const now = Date.now();
         const timeDelta = now - this.lastWheelTime;
         this.lastWheelTime = now;

         // Calculate velocity based on scroll speed
         const scrollSpeed = Math.abs(event.deltaY);
         const anglePerBook = 360 / this.books.length;

         // Add to velocity for momentum (larger scroll = more momentum)
         const momentumFactor = Math.min(scrollSpeed / 100, 3); // Cap momentum
         const direction = event.deltaY > 0 ? 1 : -1;

         this.velocity += direction * anglePerBook * 0.15 * momentumFactor;

         // Also immediately move the target
         if (event.deltaY > 10) {
           this.targetRotation += anglePerBook;
         } else if (event.deltaY < -10) {
           this.targetRotation -= anglePerBook;
         }
       },
       sampleCoverEdge(isbn) {
         // Return cached colors if already sampled
         if (this.sampledColors[isbn]) {
           return this.sampledColors[isbn];
         }

         // Create off-screen canvas to sample image
         const img = new Image();
         img.crossOrigin = 'anonymous';
         const canvas = document.createElement('canvas');
         const ctx = canvas.getContext('2d');

         // Default fallback colors
         const fallback = {
           gradient: 'linear-gradient(to bottom, #2563eb, #7c3aed)',
           solid: '#4f46e5'
         };

         img.onload = () => {
           // Store image dimensions
           this.bookDimensions[isbn] = {
             width: img.width,
             height: img.height,
             aspectRatio: img.width / img.height
           };

           canvas.width = 1;
           canvas.height = img.height;
           ctx.drawImage(img, 0, 0, 1, img.height, 0, 0, 1, canvas.height);

           // Sample colors along the left edge
           const imageData = ctx.getImageData(0, 0, 1, canvas.height);
           const colors = [];

           // Sample every few pixels to create gradient stops
           const samplePoints = Math.min(10, canvas.height);
           const step = Math.floor(canvas.height / samplePoints);

           for (let i = 0; i < canvas.height; i += step) {
             const index = i * 4;
             const r = imageData.data[index];
             const g = imageData.data[index + 1];
             const b = imageData.data[index + 2];
             colors.push('rgb(' + r + ', ' + g + ', ' + b + ')');
           }

           // Create gradient string
           const gradient = 'linear-gradient(to bottom, ' + colors.join(', ') + ')';
           const solid = colors[Math.floor(colors.length / 2)] || fallback.solid;

           this.sampledColors[isbn] = { gradient, solid };
           // Force re-render
           this.$nextTick(() => this.currentIndex = this.currentIndex);
         };

         img.onerror = () => {
           this.sampledColors[isbn] = fallback;
           this.bookDimensions[isbn] = { width: 128, height: 192, aspectRatio: 128/192 };
         };

         img.src = '/api/covers/' + isbn + '?size=M';

         return fallback;
       },
       getBookDimensions(book) {
         const isbn = book.isbn;
         // Trigger sampling if not already done
         this.sampleCoverEdge(isbn);

         // Return dimensions if available, otherwise use defaults
         const dims = this.bookDimensions[isbn];
         if (dims) {
           // Fixed height of 192px, width based on aspect ratio
           const height = 192;
           const width = height * dims.aspectRatio;
           return { width, height };
         }

         // Default dimensions while loading
         return { width: 128, height: 192 };
       },
       hasCoverError(isbn) {
         // Return true if error is explicitly set, false otherwise (including undefined)
         return this.coverLoadErrors[isbn] === true;
       },
       getSpineStyle(book) {
         const colors = this.sampleCoverEdge(book.isbn);
         return colors.gradient;
       },
       getBackColor(book) {
         const colors = this.sampleCoverEdge(book.isbn);
         return colors.solid;
       },
       getBookStyle(index) {
         const total = this.books.length;

         // Dynamic scaling based on number of books
         // Book width is ~40px (spine) when viewing from the side
         // Calculate required radius to fit all books with minimum gap
         const bookSpineWidth = 40;
         const minGap = 5; // Minimum gap between books
         const requiredCircumference = total * (bookSpineWidth + minGap);
         const calculatedRadius = requiredCircumference / (2 * Math.PI);

         // Use calculated radius, but cap it for reasonable viewing
         const radius = Math.min(Math.max(calculatedRadius, 150), 400);

         // Scale books down if there are many to prevent overlap
         // Base book size is for ~15 books at radius 200
         const baseBookCount = 15;
         const baseRadius = 200;
         const scaleFactor = Math.min(1, (radius / baseRadius) * (baseBookCount / total));
         const scale = Math.max(0.3, scaleFactor); // Don't scale below 30%

         // Calculate book's base angle position
         const baseAngle = index * (360 / total);

         // Apply rotation offset to create smooth continuous rotation
         const bookAngle = baseAngle - this.rotationOffset;
         const angle = bookAngle * (Math.PI / 180); // Convert to radians

         // Calculate position on circle
         const x = Math.sin(angle) * radius;
         const z = Math.cos(angle) * radius;

         // Full opacity - let perspective handle depth
         const opacity = 1;

         // Z-index based on z position (closer = higher)
         const zIndex = Math.round(100 + z);

         // Book rotation: spines face outward like a circular bookshelf
         const rotateY = baseAngle + 90 - this.rotationOffset;

         return {
           transform: `translate3d(${x}px, 0, ${z}px) rotateY(${rotateY}deg) scale(${scale})`,
           opacity: opacity,
           zIndex: zIndex,
           transformStyle: 'preserve-3d',
           '--book-depth': `${20 * scale}px`,
           '--spine-width': `${40 * scale}px`,
           '--cover-thickness': `${3 * scale}px`
         };
       },
       get currentBook() { return this.books[this.currentIndex]; }
     }"
     @mouseenter="isHovering = true"
     @mouseleave="isHovering = false"
     @wheel.prevent="if (isHovering) handleWheel($event)">
  
  <!-- Hover indicator -->
  <div x-show="isHovering && books.length > 1" 
       x-transition
       class="absolute top-4 left-1/2 -translate-x-1/2 z-50 bg-blue-600 text-white px-4 py-2 rounded-full text-sm font-medium shadow-lg">
    Scroll to browse books
  </div>
  
  <!-- 3D perspective container -->
  <div class="relative h-full" style="perspective: 1200px; perspective-origin: 50% 50%;">
    <div class="absolute inset-0 flex items-center justify-center">
      <!-- Tilted bookshelf container -->
      <div style="transform: rotateX(-10deg); transform-style: preserve-3d; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;">
      
      <!-- Books carousel -->
      <template x-for="(book, index) in books" :key="book.isbn">
        <div
          @click="navigate(index)"
          :style="getBookStyle(index)"
          class="absolute cursor-pointer">
          
          <!-- 3D Book with realistic thickness -->
          <div class="book-3d" :style="`transform-style: preserve-3d; width: ${getBookDimensions(book).width}px; height: ${getBookDimensions(book).height}px; position: relative;`">

            <!-- Front Cover -->
            <div class="absolute inset-0 overflow-hidden rounded-r-sm"
                 style="transform: translateZ(calc(var(--book-depth) + var(--cover-thickness))); backface-visibility: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
              <!-- Cover Image -->
              <img :src="'/api/covers/' + book.isbn + '?size=M'"
                   :alt="book.metadata?.title || 'Book Cover'"
                   class="w-full h-full object-contain absolute inset-0"
                   :style="hasCoverError(book.isbn) ? 'display: none;' : ''"
                   @error="coverLoadErrors[book.isbn] = true; console.log('Cover error for', book.isbn)"
                   @load="if ($event.target.naturalWidth <= 1 || $event.target.naturalHeight <= 1) { coverLoadErrors[book.isbn] = true; console.log('Cover has no dimensions for', book.isbn); $nextTick(() => {}); } else { coverLoadErrors[book.isbn] = false; console.log('Cover loaded for', book.isbn, $event.target.naturalWidth, $event.target.naturalHeight); }">
              <!-- Fallback cover when image unavailable -->
              <div class="w-full h-full flex items-center justify-center text-white font-bold text-center p-4 absolute inset-0"
                   :style="hasCoverError(book.isbn) ? 'background: linear-gradient(to bottom, #2563eb, #7c3aed);' : 'display: none;'">
                <div class="text-sm font-bold leading-tight" x-text="book.metadata?.title || 'Unknown Title'"></div>
              </div>
            </div>

            <!-- Front Cover Thickness (beveled edges) -->
            <!-- Right edge -->
            <div class="absolute top-0 right-0 h-full"
                 style="width: var(--cover-thickness); transform: rotateY(90deg) translateX(calc(var(--book-depth) + var(--cover-thickness))); transform-origin: right center; background: linear-gradient(to right, rgba(0,0,0,0.3), rgba(0,0,0,0.1)); backface-visibility: hidden;"></div>
            <!-- Top edge -->
            <div class="absolute top-0 left-0 w-full"
                 style="height: var(--cover-thickness); transform: rotateX(90deg) translateY(calc(var(--book-depth) + var(--cover-thickness))); transform-origin: top center; background: linear-gradient(to bottom, rgba(0,0,0,0.2), rgba(0,0,0,0.1)); backface-visibility: hidden;"></div>
            <!-- Bottom edge -->
            <div class="absolute bottom-0 left-0 w-full"
                 style="height: var(--cover-thickness); transform: rotateX(-90deg) translateY(calc((var(--book-depth) + var(--cover-thickness)) * -1)); transform-origin: bottom center; background: linear-gradient(to top, rgba(0,0,0,0.3), rgba(0,0,0,0.1)); backface-visibility: hidden;"></div>
            <!-- Left edge (connecting to spine) -->
            <div class="absolute top-0 left-0 h-full"
                 style="width: var(--cover-thickness); transform: rotateY(-90deg) translateX(calc(var(--book-depth) + var(--cover-thickness))); transform-origin: left center; background: linear-gradient(to left, rgba(0,0,0,0.3), rgba(0,0,0,0.1)); backface-visibility: hidden;"></div>

            <!-- Back Cover -->
            <div class="absolute inset-0 rounded-l-sm"
                 :style="`transform: translateZ(calc(-1 * (var(--book-depth) + var(--cover-thickness)))) rotateY(180deg); background: ${getBackColor(book)}; backface-visibility: hidden; box-shadow: 0 4px 15px rgba(0,0,0,0.2);`"></div>

            <!-- Back Cover Thickness (beveled edges) -->
            <!-- Left edge -->
            <div class="absolute top-0 left-0 h-full"
                 :style="`width: var(--cover-thickness); transform: rotateY(-90deg) translateX(calc(-1 * (var(--book-depth) + var(--cover-thickness)))); transform-origin: left center; background: linear-gradient(to left, rgba(0,0,0,0.3), rgba(0,0,0,0.1)); backface-visibility: hidden;`"></div>
            <!-- Top edge -->
            <div class="absolute top-0 left-0 w-full"
                 :style="`height: var(--cover-thickness); transform: rotateX(90deg) translateY(calc(-1 * (var(--book-depth) + var(--cover-thickness)))); transform-origin: top center; background: linear-gradient(to bottom, rgba(0,0,0,0.2), rgba(0,0,0,0.1)); backface-visibility: hidden;`"></div>
            <!-- Bottom edge -->
            <div class="absolute bottom-0 left-0 w-full"
                 :style="`height: var(--cover-thickness); transform: rotateX(-90deg) translateY(calc(var(--book-depth) + var(--cover-thickness))); transform-origin: bottom center; background: linear-gradient(to top, rgba(0,0,0,0.3), rgba(0,0,0,0.1)); backface-visibility: hidden;`"></div>
            <!-- Right edge (connecting to pages) -->
            <div class="absolute top-0 right-0 h-full"
                 :style="`width: var(--cover-thickness); transform: rotateY(90deg) translateX(calc(-1 * (var(--book-depth) + var(--cover-thickness)))); transform-origin: right center; background: linear-gradient(to right, rgba(0,0,0,0.3), rgba(0,0,0,0.1)); backface-visibility: hidden;`"></div>

            <!-- Spine (left side) -->
            <div class="absolute top-0 left-0 h-full"
                 :style="`width: var(--spine-width); transform: rotateY(-90deg) translateX(calc(-1 * var(--book-depth))); transform-origin: left center; background: ${getSpineStyle(book)}; backface-visibility: hidden; box-shadow: inset 0 0 10px rgba(0,0,0,0.3);`">
              <div class="h-full w-full flex items-center justify-center relative">
                <div class="absolute transform rotate-90 text-[10px] font-bold text-left text-white flex items-center"
                     style="text-shadow: 0 1px 3px rgba(0,0,0,0.8); width: 180px; height: 36px; line-height: 1.3; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;"
                     x-text="book.metadata?.title || 'Unknown'"></div>
              </div>
            </div>

            <!-- Spine Thickness (top and bottom edges) -->
            <!-- Top edge -->
            <div class="absolute top-0 left-0"
                 :style="`width: var(--spine-width); height: var(--cover-thickness); transform: rotateY(-90deg) translateX(calc(-1 * var(--book-depth))) rotateX(90deg) translateY(calc(-1 * var(--cover-thickness))); transform-origin: left top; background: linear-gradient(to bottom, rgba(0,0,0,0.4), rgba(0,0,0,0.2)); backface-visibility: hidden;`"></div>
            <!-- Bottom edge -->
            <div class="absolute bottom-0 left-0"
                 :style="`width: var(--spine-width); height: var(--cover-thickness); transform: rotateY(-90deg) translateX(calc(-1 * var(--book-depth))) rotateX(-90deg) translateY(var(--cover-thickness)); transform-origin: left bottom; background: linear-gradient(to top, rgba(0,0,0,0.5), rgba(0,0,0,0.2)); backface-visibility: hidden;`"></div>
            <!-- Outer edge (front) connecting spine to front cover -->
            <div class="absolute top-0 left-0 h-full"
                 :style="`width: var(--cover-thickness); transform: rotateY(-90deg) translateX(calc(-1 * var(--book-depth))) rotateY(-90deg) translateX(calc(-1 * var(--spine-width))); transform-origin: left center; background: rgba(0,0,0,0.2); backface-visibility: hidden;`"></div>
            <!-- Inner edge (back) connecting spine to back cover -->
            <div class="absolute top-0 left-0 h-full"
                 :style="`width: var(--cover-thickness); transform: rotateY(-90deg) translateX(calc(-1 * var(--book-depth))) rotateY(90deg) translateX(0px); transform-origin: left center; background: rgba(0,0,0,0.3); backface-visibility: hidden;`"></div>

            <!-- Pages (right side) - with realistic page stack effect -->
            <div class="absolute top-0 right-0 h-full"
                 style="width: var(--spine-width); transform: rotateY(90deg) translateX(var(--book-depth)); transform-origin: right center; backface-visibility: hidden;">
              <!-- Page layers with slight offsets for depth -->
              <div class="absolute inset-0 bg-gradient-to-r from-gray-100 via-white to-gray-200"
                   style="box-shadow: inset -2px 0 8px rgba(0,0,0,0.15), inset 2px 0 3px rgba(255,255,255,0.8);"></div>
              <!-- Page edge lines -->
              <div class="absolute inset-0 opacity-40"
                   style="background: repeating-linear-gradient(to right, transparent 0px, transparent 1px, rgba(0,0,0,0.08) 1px, rgba(0,0,0,0.08) 2px);"></div>
            </div>

            <!-- Top Pages Edge -->
            <div class="absolute top-0 left-0 w-full"
                 style="height: var(--spine-width); transform: rotateX(90deg) translateY(calc(-1 * var(--book-depth))); transform-origin: top center; background: linear-gradient(to bottom, #f5f5f5, #ffffff); backface-visibility: hidden; box-shadow: 0 -1px 3px rgba(0,0,0,0.2);"></div>

            <!-- Bottom Pages Edge -->
            <div class="absolute bottom-0 left-0 w-full"
                 style="height: var(--spine-width); transform: rotateX(-90deg) translateY(var(--book-depth)); transform-origin: bottom center; background: linear-gradient(to top, #e8e8e8, #f5f5f5); backface-visibility: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.2);"></div>
          </div>
        </div>
      </template>
      </div>

      <!-- Navigation arrows -->
      <button @click="prevBook()"
              class="absolute left-4 top-1/2 -translate-y-1/2 z-50 bg-white/80 hover:bg-white text-gray-700 hover:text-gray-900 p-3 rounded-full shadow-lg transition-all duration-200 opacity-70 hover:opacity-100">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
        </svg>
      </button>

      <button @click="nextBook()"
              class="absolute right-4 top-1/2 -translate-y-1/2 z-50 bg-white/80 hover:bg-white text-gray-700 hover:text-gray-900 p-3 rounded-full shadow-lg transition-all duration-200 opacity-70 hover:opacity-100">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
        </svg>
      </button>
      
    </div>
    
    <!-- Progress dots -->
    <div class="absolute bottom-4 left-1/2 -translate-x-1/2 z-50 flex space-x-2" x-show="books.length > 1">
      <template x-for="(book, index) in books" :key="'dot-' + index">
        <button @click="navigate(index)"
                :class="index === currentIndex ? 'bg-blue-600' : 'bg-white/60 hover:bg-white/80'"
                class="w-3 h-3 rounded-full transition-all duration-200 shadow-lg"></button>
      </template>
    </div>
  </div>

  <!-- Book details below carousel -->
  <div class="mt-4 px-4 text-center" x-show="currentBook">
    <h3 class="font-bold text-lg mb-1 truncate" x-text="currentBook?.metadata?.title || 'Unknown Title'"></h3>
    <p class="text-sm text-gray-600 mb-2 truncate" x-text="currentBook?.metadata?.authors?.[0] || 'Unknown Author'"></p>
    <div class="flex items-center justify-center gap-4 text-sm">
      <span class="text-gray-600">
        <span class="font-semibold" x-text="currentBook?.condition || 'N/A'"></span> Condition
      </span>
      <span class="font-bold text-green-600 text-lg" x-text="'$' + (currentBook?.estimated_price?.toFixed(2) || '0.00')"></span>
    </div>
  </div>
</div>

